window.TrackErrorCount = window.TrackErrorCount || {};window.TrackErrorCount.config = window.TrackErrorCount.config || {		"domain": "www.jollychic.com/cms/track/",		"version": "1.0.1"	};window.TrackLog = window.TrackLog || {};window.TrackLog.q = window.TrackLog.q || [];window.TrackLog.q.push(['trackLogSend']);(function () {	var zy = document.createElement('script');	var http = window.location.protocol == "https:" ? "https://" : "http://";	zy.type = 'text/javascript';	zy.async = true;	zy.src = http + window.TrackErrorCount.config.domain + window.TrackErrorCount.config.version + '/trackLog.js';	zy.id = 'trackErrorScript';	var tackJs = document.getElementById('trackErrorScript');	var s = document.getElementsByTagName('script')[0];	if (tackJs) {		tackJs.remove();		s = document.getElementsByTagName('script')[0];	}	s.parentNode.insertBefore(zy, s);})(window);//错误日志监控window.onerror = function (msg, url, line, col, error) {	//没有URL不上报！上报也不知道错误	if (msg != "Script error." && !url) {		return true;	}	//采用异步的方式	//我遇到过在window.onunload进行ajax的堵塞上报	//由于客户端强制关闭webview导致这次堵塞上报有Network Error	//我猜测这里window.onerror的执行流在关闭前是必然执行的	//而离开文章之后的上报对于业务来说是可丢失的	//所以我把这里的执行流放到异步事件去执行	//脚本的异常数降低了10倍	var unique = col + "-" + line;	if (TrackErrorCount[unique]) {		//同一个错误一次访问只需要上报一次;		return true;	}	TrackErrorCount[unique] = setTimeout(function () {		var data = {};		//不一定所有浏览器都支持col参数		col = col || (window.event && window.event.errorCharacter) || 0;		//data.url = url;		data.line = line;		data.col = col;		if (!!error && !!error.stack) {			//如果浏览器有堆栈信息			//直接使用			data.msg = error.stack.toString();		} else if (!!arguments.callee) {			//尝试通过callee拿堆栈信息			var ext = [];			var f = arguments.callee.caller, c = 3;			//这里只拿三层堆栈信息			while (f && (--c > 0)) {				ext.push(f.toString());				if (f === f.caller) {					break;//如果有环				}				f = f.caller;			}			ext = ext.join(",");			data.msg = ext;		}		if (!data.msg) {			data.msg = msg || "未知错误!";		}		//控制台显示		console.log(data);		//错误工具内部错误会导致程序一直循环		if (typeof(TrackLog) != "undefined" && typeof(TrackLog.trackLogSend) != "undefined") {			TrackLog.trackLogSend({				"_type": "pv_error",				"_info": data			}, true);			//把data上报到日志！		}	}, 500);	return true;};